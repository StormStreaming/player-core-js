import {StormPlayerCore} from "../StormPlayerCore";
import {PlaybackState} from "../playback/enum/PlaybackState";
import {Logger} from "../logger/Logger";

/**
 * Class controls the VideoElement itself
 */
export class ScreenElement {

    /**
     * Decides whenever logs are being generated by this class
     * @private
     */
    private readonly LOG_ACTIVITY: boolean = true;

    /**
     * Reference to the main class
     * @private
     */
    private _main: StormPlayerCore;

    /**
     * Current volume level (user's intention)
     * @private
     */
    private _volume: number = 100;


    private _serviceMuted: boolean = false;      // serwis wymusza (nie zapisywana)

    /**
     * Whenever video is muted (user's intention)
     * @private
     */
    private _isMuted: boolean = false;

    /**
     * Runtime flag - browser forced mute due to autoplay policy
     * @private
     */
    private _browserForcedMute: boolean = false;

    /**
     * Video Element itself
     * @private
     */
    private _videoElement: HTMLVideoElement;

    private _posterCanvas: HTMLCanvasElement | null = null;

    private _posters: HTMLCanvasElement[] = [];

    /**
     * Reference to the main logger
     * @private
     */
    private _logger: Logger;

    private _debug: boolean = false;

    //------------------------------------------------------------------------//
    // CONSTRUCTOR
    //------------------------------------------------------------------------//

    constructor(main: StormPlayerCore) {

        this._main = main;
        this._logger = main.getLogger();
        this._videoElement = document.createElement('video');
        this._debug = this._main.getConfigManager()?.getSettingsData().getDebugData().stageControllerDebug ?? this._debug;

        this._main.addEventListener("playbackForceMute", this.onForceMute, false);
        this._main.addEventListener("playbackInitiate", this.onPlaybackInitiate, false);

        let startVolume: number = this._main.getConfigManager()?.getSettingsData().getAudioData().startVolume ?? 100;
        let isMuted: boolean = this._main.getConfigManager()?.getSettingsData().getAudioData().muted ?? false;

        if (this._main.getStorageManager()?.getField("volume") != null)
            startVolume = Number(this._main.getStorageManager()!.getField("volume"));

        if (this._main.getStorageManager()?.getField("muted") != null)
            isMuted = (this._main.getStorageManager()!.getField("muted") == "true");

        this._volume = startVolume;
        this._isMuted = isMuted;

        if (this.LOG_ACTIVITY)
            this._logger.info(this, "VideoElement :: Start Volume: " + this._volume + " | Muted: " + this._isMuted);

        this._videoElement.volume = this._volume / 100;
        this._videoElement.muted = this._isMuted;

        this._videoElement.setAttribute('playsinline', 'playsinline');
        this._videoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');

        this._main.dispatchEvent("videoElementCreate", {ref: this._main, videoElement: this._videoElement});

        this.initialize();

    }

    //------------------------------------------------------------------------//
    // MAIN METHODS
    //------------------------------------------------------------------------//

    /**
     * Initializes and pre-configures main video object
     */
    public initialize(): void {

        this._videoElement.onload = function (event) {
            //console.log('videoElement.onload', event);
        }

        this._videoElement.onstalled = (event) => {
            this._logger.info(this, "VideoElement :: onstalled")
        }

        this._videoElement.onerror = (event) => {
            this._logger.info(this, "VideoElement :: onerror :: " + JSON.stringify(event))
        }

        /**
         * Fires whenever something changes video object volume
         * @param event
         */
        // @ts-ignore
        this._videoElement.onvolumechange = () => {
            // nic
        }

        this._videoElement.onpause = (event) => {
            this._logger.info(this, "VideoElement :: onpause: " + this._main.getPlaybackController()?.getPlaybackState() + " " + this._main.getNetworkController()?.getConnection().isConnectionActive())

            switch (this._main.getPlaybackController()?.getPlaybackState()) {
                //case PlaybackState.BUFFERING:
                case PlaybackState.PLAYING:

                    let container: HTMLElement | null = this._main.getStageController()!.getContainer();
                    let partOfTree: boolean = document.body.contains(container);
                    if (container && partOfTree) {

                        this._videoElement.play().then(() => {

                            this._main.getStageController()?.getScreenElement()?.deleteBlackBackground();
                            this._main.getPlaybackController()?.getPlayer()?.setPreparingToStart(false);

                            if (this._debug)
                                this._logger.decoratedLog("Playback Start", "dark-green");

                        }).catch(error => {

                            this._main.getPlaybackController()?.getPlayer()?.setPreparingToStart(false);

                            this._logger.warning(this, "Error on Play(): " + error.name + " :: " + JSON.stringify(error));

                            switch (error.name) {
                                case "NotAllowedError":
                                    this._main.getPlaybackController()?.setPlaybackState(PlaybackState.BUFFERING);
                                    this._browserForcedMute = true;
                                    this._videoElement.muted = true;
                                    this._main.dispatchEvent("playbackForceMute", {ref: this._main});
                                    break;
                                default:
                                    console.warn(error);
                            }

                        });


                    } else {

                        if (this._debug)
                            this._logger.decoratedLog("Paused due to not being part of DOM tree", "dark-yellow");

                        this._main.dispatchEvent("playbackForcePause", {ref: this._main})
                    }

                    //console.error("force pause :: container " + container + " | part of tree: " + partOfTree, event);

                    break;
            }
        }

        /**
         * Updates every second,
         * @param event
         */
        this._videoElement.ontimeupdate = function (event) {
            /*
            let newWidth: number = self.videoElement.videoWidth;
            let newHeight: number = self.videoElement.videoHeight;

            if (newWidth != 0 && newHeight != 0) {
                if (newWidth !== self.videoWidth || newHeight !== self.videoHeight) {
                    self.videoWidth = newWidth;
                    self.videoHeight = newHeight;
                    self.scaleVideo();
                }
            }
             */
        }

        // @ts-ignore
        this._videoElement.onended = (event) => {
            this._logger.info(this, "VideoElement :: onended")
        }

        this._videoElement.onplay = () => {

            this._main?.getPlaybackController()?.setPlaybackState(PlaybackState.PLAYING);

        }

    }

    /**
     * Called whenever browser stops playback due to autoplay policy
     */
    private onForceMute = () => {
        this._browserForcedMute = true;
        // NIE zmieniamy _isMuted - intencja usera pozostaje
        // NIE zapisujemy do storage
        this.dispatchVolumeEvent("browser");
    }

    /**
     * Sets new volume for playback. It'll also try to store value in a browser memory
     * @param value
     */
    public setVolume(value: number, isUserAction: boolean = false): void {

        const shouldUnmute = isUserAction && this.getIfMuted() && value > 0;
        const shouldMute = isUserAction && value == 0;

        this._volume = value;
        this._videoElement.volume = value / 100;

        if (isUserAction)
            this._main.getStorageManager()!.saveField("volume", String(value));

        if (shouldUnmute) {
            this.setMuted(false);  // wysyła event
        } else if (shouldMute) {
            this.setMuted(true);   // wysyła event
        } else {
            this.dispatchVolumeEvent(isUserAction ? "user" : "service");
        }
    }

    public getVolume(): number {
        return this._volume;
    }

    /**
     * Allows to apply mute to a video element
     * @param isMuted
     */
    public setMuted(isMuted: boolean, source: "user" | "service" = "user"): void {

        if (source === "user") {
            this._isMuted = isMuted;
            if (!isMuted) {
                // User odmutowuje - nadpisuje wszystko
                this._serviceMuted = false;
                this._browserForcedMute = false;

                if(this._volume == 0){
                    this._volume = 50;
                    this._videoElement.volume = 50 / 100;
                    this._main.getStorageManager()!.saveField("volume", String(this._volume));

                }
            }

            this._main.getStorageManager()!.saveField("muted", String(isMuted));

        } else {
            // service
            this._serviceMuted = isMuted;
        }

        this._videoElement.muted = this.getIfMuted();
        this.dispatchVolumeEvent(source);
    }

    /**
     * Returns true/false whenever video is actually muted or not
     */
    public getIfMuted(): boolean {
        return this._isMuted || this._serviceMuted || this._browserForcedMute;
    }

    /**
     * Dispatches event informing about volume change
     */


    public dispatchVolumeEvent(source: "user" | "service" | "browser" = "user"): void {
        this._main.dispatchEvent("volumeChange", {
            ref: this._main,
            volume: this._volume,
            muted: this.getIfMuted(),
            invokedBy: source
        });
    }

    /**
     * Return VideoElement
     */
    public getVideoElement(): HTMLVideoElement {
        return this._videoElement;
    }

    /**
     * Creates a poster from current video frame
     */
    public createBlackBackground(): void {

        if (!this._videoElement)
            return;

        this._videoElement.style.backgroundColor = "black";

    }

    private onPlaybackInitiate = (): void => {

        const savedVolume = this._main.getStorageManager()?.getField("volume");
        const savedMuted = this._main.getStorageManager()?.getField("muted");

        if (savedVolume != null) {
            const newVolume = Number(savedVolume);
            if (newVolume !== this._volume) {
                this._volume = newVolume;
                this._videoElement.volume = newVolume / 100;
            }
        }

        if (savedMuted != null) {
            const newMuted = (savedMuted === "true");
            if (newMuted !== this._isMuted) {
                this._isMuted = newMuted;
                this._videoElement.muted = this.getIfMuted();
            }
        }
    }

    /**
     * Removes the background poster
     */
    public deleteBlackBackground(): void {

        if (!this._videoElement)
            return;

        setTimeout(() => {
            this._videoElement.style.backgroundColor = "";
        }, 100);
    }

}