import {StormPlayerCore} from "../StormPlayerCore";
import {Logger} from "../logger/Logger";
import {ScalingType} from "../config/enum/ScalingType";
import debounce from 'lodash.debounce';
import {ScreenElement} from "./ScreenElement";
import {DomUtilities} from "../utilities/DomUtilities";
import {StormLibraryEvent} from "../events/StormLibraryEvent";
import {SizeCalculationType} from "../config/enum/SizeCalculationType";

/**
 * Class controls all visual elements of the player
 */
export class StageController {

    /**
     * Decides whenever logs are being generated by this class
     * @private
     */
    private static readonly LOG_ACTIVITY: boolean = true;

    /**
     * Video object itself (reference to object on document)
     */
    private _screenElement: ScreenElement | null;

    /**
     * Container that holds video object itself
     * @private
     */
    private _videoContainer: HTMLElement | null;

    /**
     * Parent container for the player
     * @private
     */
    private _parentElement: HTMLElement | null;

    /**
     * Video width
     * @private
     */
    private _containerWidth: number = 0;

    /**
     * Temp container width
     * @private
     */
    private _tempContainerWidth:number = 0;

    /**
     * Video height
     * @private
     */
    private _containerHeight: number = 0;

    /**
     * Temp container height
     * @private
     */
    private _tempContainerHeight:number = 0;

    /**
     * Video width (initally 0, after "onmetadata" event is updated to match the real one
     * @private
     */
    private _videoWidth: number = 0;

    /**
     * Video width (initally 0, after "onmetadata" event is updated to match the real one
     * @private
     */
    private _videoHeight: number = 0;

    /**
     * Current scaling type
     * @private
     */
    private _scalingMode: ScalingType = ScalingType.FILL;

    /**
     * If in fullscreen mode
     * @private
     */
    private isInFullScreenMode:boolean = false;

    /**
     * Reference to the main class
     * @private
     */
    private _main: StormPlayerCore;

    /**
     * Reference to the player logger
     * @private
     */
    protected _logger:Logger;

    /**
     * Watches for changes in the parent container
     * @private
     */
    private _resizeObserver:ResizeObserver;

    /**
     * Deco
     * @private
     */
    private _autoResizeEnabled:boolean = true;

    private _debug:boolean = false;

    //------------------------------------------------------------------------//
    // CONSTRUCTOR
    //------------------------------------------------------------------------//

    constructor(main: StormPlayerCore) {

        this._main = main;
        this._logger = main.getLogger();
        this._logger.info(this, "Creating new StageController")

        this._debug = this._main.getConfigManager()?.getSettingsData().getDebugData().stageControllerDebug ?? this._debug;

        this.initialize();

    }

    //------------------------------------------------------------------------//
    // MAIN METHODS
    //------------------------------------------------------------------------//
    public initialize(): void {

        // prepare data
        const containerID = this._main.getConfigManager()?.getSettingsData()?.getVideoData()?.containerID ?? null;
        this._scalingMode = this._main.getConfigManager()?.getSettingsData().getVideoData().scalingMode ?? ScalingType.FILL;

        // pre-configuration for videoContainer
        this._videoContainer = document.createElement('div');
        this._videoContainer.setAttribute("id", "stormLibrary_"+this._main.getLibraryID());
        this._videoContainer.style.overflow = "hidden";
        this._videoContainer.style.position = "relative";
        this._videoContainer.classList.add("stormLibrary")

        // pre-configuration for videoElement
        this._screenElement = new ScreenElement(this._main);
        this._videoContainer.appendChild(this._screenElement!.getVideoElement());

        const debounceValue:number = this._main.getConfigManager()!.getSettingsData().getVideoData().resizeDebounce;

        if(debounceValue > 0){
            this._resizeObserver = new ResizeObserver(debounce(() => ()=>{
                if(this._autoResizeEnabled)
                    this.onResize();

            }, debounceValue, { leading: false, trailing: true }));
        } else {
            this._resizeObserver = new ResizeObserver(()=>{
                if(this._autoResizeEnabled)
                    this.onResize()
            });
        }

        this._main.addEventListener("streamMetadataUpdate", (event)=>{
            this._videoWidth = event.metadata.videoWidth;
            this._videoHeight = event.metadata.videoHeight;
            this.onUpdateSize();
        }, false);


        document.addEventListener('fullscreenchange', this.onFullScreenChange, false);
        document.addEventListener('webkitfullscreenchange', this.onFullScreenChange, false);
        document.addEventListener('mozfullscreenchange', this.onFullScreenChange, false);
        document.addEventListener('webkitendfullscreen', this.onFullScreenChange, false);

        this._screenElement.getVideoElement().addEventListener('webkitendfullscreen', this.onFullScreenChange, false);
        this._main.addEventListener("playbackInitiate", (event:StormLibraryEvent["playbackInitiate"])=>{
            if(this._videoContainer != null){
                this._videoContainer.setAttribute("streamKey", event.streamKey)
            }
        }, false)


        if(containerID){
            this.attachToParent(containerID);
        } else
            this._logger.warning(this, `Could not create HTMLObject for the library - "containerID" was not provided`);

    }

    private onFullScreenChange = () => {

        if(document.fullscreenElement == null) {
            this.isInFullScreenMode = false;
            this._logger.info(this, "The library has exited FullScreen mode!");
            this._main.dispatchEvent("fullScreenExit", {ref:this._main});
        } else {
            this.isInFullScreenMode = true;
            this._logger.info(this, "The library has entered FullScreen mode!");
            this._main.dispatchEvent("fullScreenEnter", {ref:this._main});
        }

    }

    /**
     * Method attaches element to a parent container
     *
     * @param container
     */
    public attachToParent(container: string | HTMLElement): boolean {

        // preparing elements
        let result:boolean = false; // To indicate the success of the operation
        let tempParentElement: HTMLElement | null = null;

        // Check if container is either an ID string or an HTMLElement instance
        if (typeof container === "string") {

            this._logger.info(this, "Attaching container to ID: "+container)

            tempParentElement = document.getElementById(container);

        } else if (container instanceof HTMLElement) {

            this._logger.info(this, "Attaching container to HTMLElement: "+container)
            tempParentElement = container;

        }

        // Check if the new container is not the same as the old one
        if (tempParentElement === this._parentElement) {

            if(this._debug)
                this._logger.decoratedLog("Attaching Failed (container is the same)", "dark-pink");

            this._logger.warning(this, "attachToParent :: container is the same");
            return false;
        }

        // If a valid container is found and _videoContainer exists, append it
        if (tempParentElement && this._videoContainer) {

            if(this._debug)
                this._logger.decoratedLog("Attach To Parent: "+container+" (success)", "dark-pink");

            this._parentElement = tempParentElement;
            this._parentElement.appendChild(this._videoContainer);
            this._resizeObserver.observe(this._parentElement);
            this._parentElement.addEventListener("transitionend",()=>{this.onResize();})
            this._main.dispatchEvent("containerChange", {ref:this._main, container: this._parentElement })

            this.onResize();

            result = true; // Operation successful
        } else {

            if(this._debug)
                this._logger.decoratedLog("Attach To Parent: "+container+" (failure - container not found)", "dark-pink");

            this._logger.warning(this, "attachToParent :: container \""+container+"\"+ was not found");
        }

        return result; // Return the result of the operation
    }

    /**
     * Detaches the library from a parent container
     */
    public detachFromParent():boolean {

        if(this._debug)
            this._logger.decoratedLog("Detach From Parent", "dark-pink");

        let result: boolean = false;

        if(this._parentElement != null && this._videoContainer != null){
            this._logger.info(this, "Detaching from parent: "+this._videoContainer);
            this._parentElement.removeChild(this._videoContainer);

            if (this._resizeObserver) {
                this._resizeObserver.unobserve(this._parentElement);
                this._resizeObserver.disconnect();
            }

            if(this._autoResizeEnabled)
                this._parentElement.removeEventListener("transitionend", this.onResize);

            this._main.dispatchEvent("containerChange", {ref:this._main, container: null })

            result = true;
        } else {
            this._logger.info(this, "Failed detaching from parent!");
        }

        this._parentElement = null;

        return result;

    }

    public onResize = (): void => {

        if(this._parentElement != null) {

            this.onUpdateSize();
            this._main.dispatchEvent("resizeUpdate", {ref:this._main, width: this._tempContainerWidth, height:this._tempContainerHeight});

        }
    }

    public onUpdateSize = (): void => {

        if(this._parentElement != null) {

            const calcMethod:SizeCalculationType = this._main.getConfigManager()!.getSettingsData().getVideoData().parentSizeCalculationMethod;

            this._videoContainer!.style.display = "none";

            switch(calcMethod){
                case SizeCalculationType.CLIENT_DIMENSIONS:
                    this._tempContainerWidth = this._parentElement.clientWidth;
                    this._tempContainerHeight = this._parentElement.clientHeight;
                    break;
                case SizeCalculationType.BOUNDING_BOX:
                    this._tempContainerWidth = this._parentElement.getBoundingClientRect().width;
                    this._tempContainerHeight = this._parentElement.getBoundingClientRect().height;
                    break;
                case SizeCalculationType.FULL_BOX:
                    this._tempContainerWidth = DomUtilities.calculateDimensionsWithMargins(this._parentElement).width;
                    this._tempContainerHeight = DomUtilities.calculateDimensionsWithMargins(this._parentElement).height;
                    break;
            }

            this._logger.info(this,"onResize called: "+this._tempContainerWidth+"x"+this._tempContainerHeight+" ("+calcMethod+")");

            this.resizeVideoContainer();
            this.scaleVideo();

            this._videoContainer!.style.display = "block";

        }
    }

    /**
     * Method resizes video container
     * @private
     */
    private resizeVideoContainer():void {

        const isWidthInPX:boolean = this._main.getConfigManager()!.getSettingsData().getVideoData().videoWidthInPixels;
        const isHeightInPX:boolean = this._main.getConfigManager()!.getSettingsData().getVideoData().videoHeightInPixels;
        const videoWidthVal:number = this._main.getConfigManager()!.getSettingsData().getVideoData().videoWidthValue;
        const videoHeightVal:number = this._main.getConfigManager()!.getSettingsData().getVideoData().videoHeightValue;
        const aspectRatio:string = this._main.getConfigManager()!.getSettingsData().getVideoData().aspectRatio;

        let finalVideoWidth:number = 0;
        let finalVideoHeight:number= 0;

        let aspectWRatio:number = Number(aspectRatio.split(":")[0]);
        let aspectHRatio:number = Number(aspectRatio.split(":")[1]);

        if(aspectRatio == "none"){

            if(isWidthInPX){
                finalVideoWidth = videoWidthVal;
            } else {
                if(this._parentElement != null)
                    finalVideoWidth = (this._tempContainerWidth*videoWidthVal/100);
            }

            if(isHeightInPX){
                finalVideoHeight = videoHeightVal;
            } else {
                if(this._parentElement != null) {
                    finalVideoHeight = (this._tempContainerHeight * videoHeightVal / 100);

                    if(finalVideoHeight == 0 && this._videoHeight != 0 && this._videoWidth != 0)
                        finalVideoHeight = (this._videoHeight * finalVideoWidth / this._videoWidth);

                }

            }

        } else {

            if(isWidthInPX){
                finalVideoWidth = videoWidthVal;
            } else {
                if(this._parentElement != null)
                    finalVideoWidth = (this._tempContainerWidth*videoWidthVal/100);

            }

            finalVideoHeight = (finalVideoWidth * aspectHRatio / aspectWRatio);

        }

        this._containerWidth = Math.ceil(finalVideoWidth);
        this._containerHeight = Math.ceil(finalVideoHeight);

        if (this._videoContainer !== null) {
            this._videoContainer.style.width = this._containerWidth + "px";
            this._videoContainer.style.height = this._containerHeight + "px";
        }

    }

    private scaleVideo(): void {

        if (this._screenElement !== null) {

            let videoX: number = 0;
            let videoY: number = 0;
            let videoWidth: number = 0;
            let videoHeight: number = 0;

            switch (this._scalingMode) {
                //--- FILL, covers 100% of width & height
                case ScalingType.FILL: {

                    videoWidth = this._containerWidth;
                    videoHeight = this._containerHeight;

                }
                break;
                //--- CROP
                case ScalingType.CROP: {

                    videoWidth = this._containerWidth;
                    videoHeight = (this._videoHeight * this._containerWidth / this._videoWidth);

                    if (videoHeight >= this._containerHeight) {

                        videoX = 0;
                        videoY = ((videoHeight - this._containerHeight) / 2) * -1;

                    } else {

                        videoHeight = this._containerHeight;
                        videoWidth = (this._videoWidth * this._containerHeight / this._videoHeight);

                        videoY = 0;
                        videoX = ((videoWidth - this._containerWidth) / 2) * -1;

                    }
                }
                break;
                //--- LETTER BOX
                case ScalingType.LETTER_BOX: {

                    // jeżeli szerokość
                    videoWidth = this._containerWidth;

                    videoHeight = (this._videoHeight * this._containerWidth / this._videoWidth);

                    if (videoHeight <= this._containerHeight) {
                        videoX = 0;
                        videoY = (videoHeight - this._containerHeight) / 2 * -1;

                        if (videoHeight > this._containerHeight) {

                            videoHeight = this._containerHeight;
                            videoWidth = (this._videoWidth * this._containerHeight / this._videoHeight);

                            videoY = 0;
                            videoX = ((videoWidth - this._containerWidth) / 2) * -1;

                        }

                    } else {
                        videoHeight = this._containerHeight;
                        videoWidth = (this._videoWidth * this._containerHeight / this._videoHeight);

                        videoY = 0;
                        videoX = ((videoWidth - this._containerWidth) / 2) * -1;

                    }
                }
                break;
                //--- ORIGINAL
                case ScalingType.ORIGINAL: {

                    videoWidth = this._videoWidth;
                    videoHeight = this._videoHeight;
                    videoX = (this._videoWidth - this._containerWidth) / -2;
                    videoY = (this._videoHeight - this._containerHeight) / -2;

                    break;
                }

            }

            this._screenElement.getVideoElement()!.style.left =  Math.floor(videoX) + "px";
            this._screenElement.getVideoElement()!.style.top = Math.floor(videoY) + "px";
            this._screenElement.getVideoElement()!.style.width = Math.ceil(videoWidth) + "px";
            this._screenElement.getVideoElement()!.style.height = Math.ceil(videoHeight) + "px";
            this._screenElement.getVideoElement()!.style.position = "absolute";
            this._screenElement.getVideoElement()!.style.objectFit = "fill";

        }

    }

    public enterFullScreen():void {

        // @ts-ignore
        if (this._screenElement?.getVideoElement().webkitEnterFullScreen) {
            // @ts-ignore
            this._screenElement?.getVideoElement().webkitEnterFullScreen();
        } else {
            this._screenElement?.getVideoElement().requestFullscreen();
        }

    }

    public exitFullScreen():void {

        // @ts-ignore
        if(this._screenElement?.getVideoElement().webkitExitFullscreen){
            // @ts-ignore
            document.webkitExitFullscreen();
        } else {
            document.exitFullscreen();
        }

    }

    public isFullScreenMode():boolean {
        return this.isInFullScreenMode;
    }

    //------------------------------------------------------------------------//
    // SETS & GETS
    //------------------------------------------------------------------------//

    private setDimension(key: 'width' | 'height', value: number | string): void {

        const dimensionKey = key === 'width' ? 'videoWidth' : 'videoHeight';
        let valueInPixels: boolean;
        let numericValue: number;

        if (typeof value === "number") {
            numericValue = value;
            valueInPixels = true;
        } else if (typeof value === "string") {
            numericValue = parseInt(value);
            valueInPixels = value.toLowerCase().endsWith('px');
        } else {
            throw new Error(`Unknown value for parameter "${key}" - it must be a number or a string!`);
        }

        this._main.getConfigManager()!.getSettingsData().getVideoData()[`${dimensionKey}Value`] = numericValue;
        this._main.getConfigManager()!.getSettingsData().getVideoData()[`${dimensionKey}InPixels`] = valueInPixels;

        this.resizeVideoContainer();
        this.scaleVideo();
    }

    public setSize(width: number | string, height: number | string): void {
        this.setDimension('width', width);
        this.setDimension('height', height);
        this._main?.getQualityController()?.onPlayerResize();
    }

    public setWidth(width: number | string): void {
        this.setDimension('width', width);
        this._main?.getQualityController()?.onPlayerResize();
    }

    public setHeight(height: number | string): void {
        this.setDimension('height', height);
        this._main?.getQualityController()?.onPlayerResize();
    }

    public getParentElement():HTMLElement | null {
        return this._parentElement;
    }

    public setScalingMode(newMode: ScalingType) {
        switch (newMode.toLowerCase()) {
            case "fill":
                this._scalingMode = ScalingType.FILL;
                break;
            case "crop":
                this._scalingMode = ScalingType.CROP;
                break;
            case "letterbox":
                this._scalingMode = ScalingType.LETTER_BOX;
                break;
            case "original":
                this._scalingMode = ScalingType.ORIGINAL;
                break;
        }

        this.scaleVideo();
    }

    public getContainerWidth():number {
        return this._containerWidth;
    }

    public getContainerHeight():number {
        return this._containerHeight;
    }

    public getScalingModeAsString():string {
        let scalingName:string = "";

        switch(this._scalingMode){
            case ScalingType.FILL:
                scalingName = "fill"
                break;
            case ScalingType.CROP:
                scalingName = "crop"
                break;
            case ScalingType.LETTER_BOX:
                scalingName = "letterbox"
                break;
            case ScalingType.ORIGINAL:
                scalingName = "original"
                break;
        }

        return scalingName;
    }

    public getScalingMode():ScalingType {
        return this._scalingMode
    }

    public getScreenElement():ScreenElement | null {
        return this._screenElement;
    }

    public getContainer():HTMLElement | null {
        return this._videoContainer;
    }



    //------------------------------------------------------------------------//
    // CLEANUP
    //------------------------------------------------------------------------//
    public destroy():void {
        this.detachFromParent();

    }





}